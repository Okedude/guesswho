<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wer Bin Ich? & Zimmerordnung</title>
    <!-- Tailwind CSS laden -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            min-height: 100vh;
        }
        .container-card {
            background: #ffffff;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
            border-radius: 1.5rem;
            max-width: 95%;
            width: 1000px; 
        }
        .btn-primary {
            transition: all 0.15s ease-in-out;
            border: 2px solid;
            background-color: #4f46e5; /* indigo-600 */
        }
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(79, 70, 229, 0.4);
        }
        .btn-disabled {
            background-color: #a5b4fc; /* indigo-300 */
            cursor: not-allowed;
        }
        .draggable-person {
            cursor: grab;
        }
        .drop-zone {
            min-height: 4rem;
            border: 2px dashed #9ca3af; /* gray-400 */
            transition: background-color 0.2s;
        }
        .drop-zone.drag-over {
            background-color: #eef2ff; /* indigo-50 */
            border-color: #4f46e5; /* indigo-600 */
        }
        .conflict-new {
             background-color: #fee2e2; /* red-100 */
             border: 1px solid #f87171; /* red-400 */
             padding: 0.25rem 0.5rem;
             border-radius: 0.5rem;
             font-size: 0.8rem;
             cursor: help; /* Zeigt an, dass es interaktiv ist */
             transition: background-color 0.15s;
        }
        .conflict-new:hover {
            background-color: #fca5a5; /* red-300 */
        }
        .room-card {
            transition: border 0.2s, box-shadow 0.2s;
        }
        .management-btn {
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            transition: background-color 0.15s;
        }
        .sick-person {
             background-color: #fca5a5 !important; /* red-300 */
             color: #7f1d1d !important; /* red-900 */
        }
    </style>
</head>
<body class="flex items-start justify-center p-4">
    <!-- Tais Math Challenge Modal -->
    <div id="tais-math-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50" style="display:none;">
        <div class="bg-white p-6 rounded-2xl shadow-2xl w-full max-w-md">
            <h3 class="text-2xl font-bold text-indigo-700 mb-4">Tais's Logik-Test (NEU)</h3>
            <p class="mb-4 text-gray-700">
                L√∂se die *neue* mathematische Aufgabe. Sie √§ndert sich jedes Spiel! 
                <span class="font-bold text-red-600">Scheitern = TOTKRANK!</span>
            </p>
            
            <div class="p-4 bg-yellow-50 border border-yellow-200 rounded-xl mb-4">
                <p class="font-mono text-lg font-bold text-gray-800" id="math-question">
                    <!-- Frage wird dynamisch per JS eingef√ºgt -->
                </p>
            </div>

            <label for="tais-math-answer" class="block text-sm font-medium text-gray-600 mb-2">Deine Antwort (nur Zahl eingeben):</label>
            <input type="number" id="tais-math-answer" placeholder="Zahl" class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:ring-indigo-500 focus:border-indigo-500">
            
            <div class="flex space-x-3">
                <button id="submit-tais-math" class="btn-primary flex-grow text-white p-3 rounded-xl font-bold border-indigo-500">
                    Antwort absenden
                </button>
                <button id="cancel-tais-math" class="bg-gray-300 hover:bg-gray-400 text-gray-800 p-3 rounded-xl font-bold">
                    Abbrechen (Tais wird krank!)
                </button>
            </div>
            <p id="tais-math-error" class="text-red-600 text-sm mt-3" style="display:none;"></p>
        </div>
    </div>
    
    <main class="container-card p-8 mt-8">
        <div id="app-container">
            <h1 class="text-3xl font-bold mb-4 text-gray-800">Klassenfahrt Spiele</h1>
            
            <div id="mode-switcher" class="flex justify-center space-x-4 mb-6">
                <button id="switch-guess" data-mode="guess" class="px-4 py-2 font-semibold rounded-lg border border-indigo-500 text-indigo-700 hover:bg-indigo-50">
                    Wer Bin Ich?
                </button>
                <button id="switch-room" data-mode="room" class="px-4 py-2 font-semibold rounded-lg bg-indigo-500 text-white shadow-md">
                    Zimmerordnung
                </button>
            </div>
            
            <div id="message-box" style="display:none;"></div>

            <div id="guess-game" style="display:none;">
                <!-- Wer Bin Ich? (RATESPIEL) - Nicht relevant f√ºr diesen Request -->
                <div class="p-4 bg-gray-100 border border-gray-200 rounded-xl mb-6 flex justify-between items-center">
                    <div class="flex flex-col">
                        <label for="display-name" class="block text-xs font-medium text-gray-600 mb-1">Dein Name</label>
                        <input type="text" id="display-name" placeholder="Spielername" class="bg-gray-100 font-bold text-lg text-gray-800 border-none p-0 focus:ring-0" maxlength="15">
                    </div>
                    <div class="text-right">
                        <p class="text-sm text-gray-600">Aktueller Streak:</p>
                        <span id="current-streak" class="text-3xl font-extrabold text-indigo-600">0</span>
                    </div>
                </div>

                <div class="p-6 bg-indigo-50 border border-indigo-200 rounded-2xl mb-6">
                    <h2 class="text-xl font-bold text-indigo-800 mb-4">Hinweise zur gesuchten Person:</h2>
                    <div id="hint-list" class="space-y-2 mb-4 text-indigo-700">
                        <p class="text-base font-medium italic">Spiel wird gestartet...</p>
                    </div>
                    <div id="hint-controls" class="border-t border-indigo-200 pt-4 mt-4">
                        <button id="request-hint-btn" class="btn-primary w-full text-white p-3 rounded-xl font-bold text-sm" disabled>
                            N√§chsten Tipp anfordern (<span id="time-remaining">30</span>s)
                        </button>
                    </div>
                </div>

                <div class="mb-4">
                    <h2 class="text-xl font-semibold mb-3 text-gray-700">Dein Tipp</h2>
                    <div class="flex space-x-3">
                        <input type="text" id="guess-input" 
                               placeholder="Name hier eingeben" 
                               list="name-options" 
                               class="flex-grow p-3 border border-gray-300 rounded-xl focus:ring-indigo-500 focus:border-indigo-500">
                        <datalist id="name-options"></datalist>
                        <button id="submit-guess-btn" class="btn-primary text-white p-3 rounded-xl font-bold px-6 border-indigo-500">Raten</button>
                    </div>
                    <p class="text-xs text-gray-500 mt-2">Du musst den Namen aus der Liste korrekt eingeben.</p>
                </div>
                
                <button id="reset-game-btn" class="mt-4 w-full text-center text-sm text-gray-500 hover:text-red-500 transition duration-150">Streak zur√ºcksetzen</button>
            </div>

            <div id="room-game" style="display:block;">
                <!-- Zimmerordnung (ZUORDNUNGSSPIEL) -->
                <h2 class="text-2xl font-bold mb-4 text-gray-800">Zimmerordnung & Virenmanagement</h2>

                <div class="grid grid-cols-1 lg:grid-cols-3 gap-4 mb-6">
                    <!-- Status und Zeit -->
                    <div id="room-status" class="p-4 bg-yellow-50 border border-yellow-200 rounded-xl text-sm text-yellow-800 font-medium space-y-1 col-span-1">
                        <p class="font-bold text-base text-gray-700 mb-1">Logistik-Status</p>
                        <p>Total Zimmer: <span id="total-rooms">0</span></p>
                        <p class="font-bold text-green-700">Gesamtkapazit√§t: <span id="used-capacity">0</span> von <span id="total-capacity">0</span> (Garantiert 20!)</p>
                        <p class="border-t border-yellow-200 pt-2 mt-2 font-bold">Verstrichene Zeit: <span id="room-timer" class="font-extrabold text-xl text-red-600">0s</span></p>
                    </div>
                    
                    <!-- Krankheitsstatus -->
                    <div class="p-4 bg-red-50 border border-red-200 rounded-xl text-sm text-red-800 font-medium col-span-1">
                        <p class="font-bold text-base text-gray-700 mb-2">Krankheits-Status (Achtung!)</p>
                        <p>Kranke Personen ü§í: <span id="sick-count" class="font-extrabold text-red-700 text-lg">0</span> von 20</p>
                        <p class="text-xs mt-2 border-t border-red-200 pt-2 text-red-700">Krank: <span id="sick-list"></span></p>
                    </div>

                    <!-- Dynamische Konflikte -->
                    <div id="dynamic-conflict-area" class="p-4 bg-indigo-50 border border-indigo-200 rounded-xl text-sm text-indigo-800 font-medium col-span-1">
                        <p class="font-bold text-base text-gray-700 mb-2">Dynamische Konflikte (Eskalation)</p>
                        <div id="dynamic-conflicts-list" class="flex flex-wrap gap-2 h-10 overflow-y-auto">
                            <p class="text-xs italic text-indigo-600">Noch keine neuen Konflikte.</p>
                        </div>
                        <p class="text-xs mt-2 border-t border-indigo-200 pt-2 text-indigo-700">N√§chste Eskalation in: <span id="conflict-countdown">30</span>s | Vergebungs-Check in: <span id="forgiveness-countdown">60</span>s</p>
                    </div>
                </div>
                
                <div class="p-3 bg-orange-100 border border-orange-400 rounded-xl mb-6 text-sm text-orange-800">
                    <p class="font-bold mb-1">Heizungs-Regel: Diese Personen ben√∂tigen ein Zimmer mit Heizung (üî•):</p>
                    <p class="text-xs">Adriana S., Luc, Sean, Nila</p>
                </div>
                
                <!-- DEDIZIERTER BEREICH F√úR KONFLIKTGESCHICHTEN -->
                 <div id="conflict-story-display" class="p-3 bg-red-50 border border-red-300 rounded-xl mb-6 text-sm text-red-800" style="display:none;">
                    <p class="font-bold mb-1 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2" viewBox="0 0 20 20" fill="currentColor">
                          <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                        </svg>
                        Konflikt-Hintergrund: <span id="conflict-pair-display" class="font-extrabold ml-1"></span>
                    </p>
                    <p id="conflict-reason-text" class="text-xs"></p>
                </div>


                <!-- Personen zum Zuweisen -->
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-2 text-gray-700">Unzugewiesene Personen (<span id="unassigned-count">20</span>)</h3>
                    <div id="unassigned-persons" class="flex flex-wrap gap-2 p-3 bg-gray-100 rounded-xl drop-zone border-gray-300">
                        <!-- Personen-Tags werden hier eingef√ºgt -->
                    </div>
                </div>

                <!-- Zimmer-Container -->
                <div class="space-y-4">
                    <h3 class="text-lg font-semibold text-gray-700">Zimmerplan (Kranke und Gesunde m√ºssen getrennt werden!)</h3>
                    <div id="room-layout" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Zimmer werden hier eingef√ºgt -->
                    </div>
                </div>
                
                <!-- Bewertungs-Button -->
                <button id="submit-rooms-btn" class="mt-6 w-full btn-primary text-white p-3 rounded-xl font-bold px-6 border-indigo-500">
                    Zimmerordnung absenden & Final bewerten
                </button>

                <button id="new-room-game-btn" class="mt-4 w-full text-center text-sm text-gray-500 hover:text-indigo-500 transition duration-150">
                    Neue Zimmerordnung starten
                </button>
                
                <div id="room-results" class="mt-6 p-4 border rounded-xl" style="display:none;">
                    <h3 class="text-xl font-bold mb-2">Bewertungsergebnis</h3>
                    <p id="room-result-text"></p>
                </div>

            </div>
        </div>
    </main>

    <script>
        // --- ALLGEMEINE SPIELKONSTANTEN ---
        const NAME_POOL_GUESS = [
            // Namen wie zuvor, gek√ºrzt f√ºr die √úbersichtlichkeit
            { name: "Nila", tips: ["Ist offen und hilfsbereit.", "Hat blonde Haare."] },
            { name: "Adriana S.", tips: ["Hat braune Haare und braune Augen.", "Nutzt ein Moncler Brillenetui."] },
            { name: "Ellison", tips: ["Ist politisch engagiert.", "Ist blond und hat Sommersprossen."] },
            { name: "Julia", tips: ["Hat braune Haare.", "Hat immer Skyr dabei."] },
            { name: "Tim", tips: ["Ist sehr lustig.", "Kann als Konsumopfer bezeichnet werden."] },
            { name: "William", tips: ["War in der Mongolei.", "Ist lustig und spielt gerne Schach."] },
            { name: "Jacob", tips: ["Ist fast immer am Computer.", "Tr√§gt einen schwarzen Schulthek."] },
            { name: "Tim-Oliver", tips: ["Ist immer am Lernen.", "Tr√§gt immer eine M√ºtze."] },
            { name: "Leif", tips: ["Macht eigene Musik.", "Sagt oft \"Ich bin perfekt!\"."] },
            { name: "Max", tips: ["Ist neu in der Klasse.", "Ist Coiffeur (Friseur)."] },
            { name: "Tais", tips: ["Spricht Franz√∂sisch.", "Behauptet, er kann Mathe perfekt."] },
            { name: "Elisa", tips: ["Hat blonde Haare und ist klein.", "Kann als Konsumopfer gelten."] },
            { name: "Zofia", tips: ["Ist immer mit Emma E. zusammen.", "Liebt das Fach Mathematik."] },
            { name: "Elin", tips: ["Hat einen 20m Pool.", "Wurde im Bergwaldprojekt sofort krank."] },
            { name: "Cedric", tips: ["Ist GC Fan (Grasshopper Club Z√ºrich).", "Spielt Fussball."] },
            { name: "Luc", tips: ["Bestellt viel.", "Hat einen Buzzcut."] },
            { name: "Sean", tips: ["Tr√§gt meistens Ralph Lauren.", "Hat einen Mittelscheitel."] },
            { name: "Anna G.", tips: ["Ist immer auf GrowMyGarden.", "Spielt Poki."] },
            { name: "Anna P.", tips: ["Hat lange, braune Haare.", "Ist immer auf Poki."] },
            { name: "Jara", tips: ["Spielt auch immer Poki.", "Besitzt ein ThinkPad."] }
        ];

        // --- ZIMMERORDNUNG KONSTANTEN ---
        const CLASS_SIZE = 20;
        const PERSON_NAMES = NAME_POOL_GUESS.map(p => p.name);
        
        // Personen, die eine Heizung ben√∂tigen
        const NO_HEATING_TOLERANCE_PEOPLE = ["Adriana S.", "Luc", "Sean", "Nila"];
        
        // Feste Konflikte (MIT HINTERGRUNDGESCHICHTE)
        const CONFLICT_PAIRS_FIXED = [
            ["Zofia", "Tim", "Tim hat Zofias Stifte f√ºr seine Doodles ohne Erlaubnis benutzt, was bei Zofia, die sehr ordentlich ist, zu einem Tobsuchtsanfall f√ºhrte. Der Konflikt dreht sich um Respekt vor Eigentum."], 
            ["Tim-Oliver", "Luc", "Luc h√∂rt seine Hip-Hop-Musik immer √ºber Lautsprecher, w√§hrend Tim-Oliver absolute Ruhe zum Lernen braucht. Ein unl√∂sbarer Konflikt zwischen Entspannung und Leistung."], 
            ["Ellison", "Jacob", "Ellison ist √ºberzeugt, dass man sich politisch engagieren muss, w√§hrend Jacob nur in seiner Computerwelt lebt und die echte Welt ignoriert. Dieser fundamentale Weltanschauungskonflikt kocht bei jeder Diskussion hoch."], 
            ["Adriana S.", "Anna G.", "Sie streiten sich seit dem 5. Schuljahr darum, wer das sch√∂nere Federm√§ppchen besitzt. Es ist ein eitler, aber tiefer Groll."], 
            ["Nila", "Jacob", "Nila ist sehr ordentlich und extrovertiert, Jacob ist chaotisch und introvertiert. Nila kann Jacobs Unordnung nicht ertragen, die sie als Zeichen von Respektlosigkeit interpretiert."], 
            ["Julia", "Tim", "Tim machte einen Witz √ºber Julias st√§ndigen Skyr-Konsum ('Du bist doch eine wandelnde Molkerei!'), was Julia zutiefst beleidigte."], 
            ["Ellison", "Tim", "Ellison ist Tim zu laut und Tim findet Ellisons st√§ndige moralische Appelle anstrengend. Es ist ein Konflikt der Lautst√§rke und des Temperaments."], 
            ["William", "Tim-Oliver", "William findet, dass Tim-Oliver zu verbissen lernt und das Leben verpasst. Tim-Oliver h√§lt William f√ºr einen Zeitverschwender. Die unterschiedliche Einstellung zur Zukunft f√ºhrt zu Spannung."], 
            ["Tim", "Tim-Oliver", "Sie sind Namensvetter, aber charakterliche Gegens√§tze. Tim √§rgert Tim-Oliver st√§ndig, indem er seine M√ºtze versteckt."],
            ["Max", "Adriana S.", "Max hat versehentlich Adriana S.'s neue, teure Sonnenbrille fallen gelassen und nicht sofort zugegeben. Adriana S. h√§lt Max f√ºr unverantwortlich."],
            ["Leif", "Cedric", "Cedric behauptete Leifs Musik sei 'nur L√§rm'. F√ºr Leif, dessen Musik sein Ein und Alles ist, ist das ein Kampf."],
            ["Zofia", "Nila", "Ein Streit um die beste Sitzordnung im Bus; Zofia wollte den Fensterplatz, den Nila bereits reserviert hatte. Sie sprechen seither nicht mehr miteinander."],
            ["Elin", "Adriana S.", "Elin erz√§hlte im Vertrauen ein Geheimnis, das Adriana S. versehentlich weitergab. Elin f√ºhlt sich verraten."],
            ["Tais", "Nila", "Tais behauptet Nila k√∂nne kein Franz√∂sisch, obwohl Tais selbst kein Muttersprachler ist. Es geht um Angeberei und Kompetenz-Anspr√ºche."],
            ["Elisa", "Cedric", "Elisa ist ver√§rgert, weil Cedric immer alle Witze √ºber das Konsumverhalten macht, die sie als pers√∂nliche Angriffe empfindet."],
            ["Cedric", "Tim", "Sie sind beide Fussballfans, aber Cedric ist GC Fan und Tim ist ein YB-Hasser. Der Konflikt ist rein sportlicher Natur, aber sehr emotional."],
            ["Sean", "Tim", "Tim hat Seans geliebtes Ralph-Lauren-Shirt mit einem Ketchup-Fleck ruiniert. Tim hat es nicht ersetzt, da er es 'nur lustig' fand."],
            ["Luc", "Tim", "Luc f√ºhlt sich von Tims st√§ndigen Witzen √ºber seinen Buzzcut pers√∂nlich angegriffen. Er sieht es als Mobbing."],
            ["Anna G.", "Ellison", "Anna G. findet Ellisons politisches Geschw√§tz zu viel, Ellison findet Anna G.'s st√§ndiges Poki-Spielen unproduktiv. Wieder ein Konflikt der Lebensphilosophien."],
            ["Anna P.", "Ellison", "√Ñhnlich wie bei Anna G., aber Anna P. wirft Ellison zus√§tzlich vor, 'zu perfekt' sein zu wollen."],
            ["Jara", "Ellison", "Ellison verspottete Jaras altes ThinkPad als 'Museumsst√ºck', was Jara verletzt hat, da es ein Geschenk war."],
        ];

        // NEUE Dynamische Konflikte (MIT HINTERGRUNDGESCHICHTE)
        const NEW_CONFLICT_POOL = [
            ["Max", "Jacob", "Max und Jacob stritten sich um den letzten Donut, der eigentlich f√ºr den Lehrer gedacht war. Gier besiegt Anstand."], 
            ["William", "Ellison", "Sie hatten eine hitzige Debatte dar√ºber, ob man nach dem Motto 'YOLO' leben sollte (William) oder ob das verantwortungslos ist (Ellison)."], 
            ["Tim", "Sean", "Tim hat sich √ºber Seans neuste, sehr teure Turnschuhe lustig gemacht, was Sean als extrem respektlos empfand."], 
            ["Julia", "Zofia", "Julia hat Zofia versehentlich in der Mensa angerempelt, was Zofia als absichtliche Provokation auffasste, da sie Julia nicht mag."],
            ["Cedric", "Elisa", "Elisa behauptet, Cedric w√ºrde immer die besten Pl√§tze im Bus reservieren, was Cedric als haltlose L√ºge abtut."],
            ["Leif", "Max", "Max fragte einmal, ob Leifs Musik √ºberhaupt 'echte Musik' sei, was Leifs K√ºnstlerseele tief traf."],
            ["Jara", "Tais", "Jara und Tais stritten sich stundenlang dar√ºber, ob Android oder iOS das √ºberlegene Betriebssystem sei."],
            ["Elin", "Tim", "Elin ist genervt von Tims Angewohnheit, st√§ndig mit Essen im Mund zu reden."],
            ["Adriana S.", "Luc", "Ein unbedachter Kommentar von Luc √ºber Adriana S.'s neue Jacke f√ºhrte zu tagelangem Schweigen."],
            ["Anna G.", "Max", "Max hat Anna G.'s Highscore in einem Online-Spiel geschlagen und ihr dann seine '√úberlegenheit' in einem Chat-Spam unter die Nase gerieben."],
            ["Julia", "Nila", "Ein Missverst√§ndnis √ºber eine Gruppenarbeit, bei der Nila dachte, Julia h√§tte ihre Arbeit gestohlen, obwohl Julia nur helfen wollte."],
            ["William", "Luc", "William findet Lucs Verhalten als 'zu viel' und Luc findet Williams lockere Art 'naiv'."],
        ];
        
        const CONFLICT_ESCALATION_INTERVAL = 30 * 1000; // 30 Sekunden
        const CONFLICT_FORGIVENESS_INTERVAL = 60 * 1000; // 60 Sekunden
        const INFECTION_CHECK_INTERVAL = 60 * 1000; // 60 Sekunden
        
        // --- GLOBALER SPIELSTATUS ---
        let gameState = 'room'; 
        
        // --- ROOM GAME STATUS (ERWEITERT) ---
        let rooms = [];
        let sickPersons = []; 
        let roomProblemIds = [];
        let dynamicConflicts = []; // Aktivierte Hass-Paare
        let roomStartTime = 0; 
        let roomTimerInterval = null; 
        let nextConflictIndex = 0; 
        let lastForgivenessTime = 0;
        let lastInfectionCheckTime = 0;
        let isTaisMathSolved = false; // Status des Mathe-Tests
        let taisMathProblem = {}; // NEU: Speichert das dynamisch generierte Problem
        
        // Management Status (Key: RoomID, Value: {lastVent, isDoorClosed, areMasksWorn})
        let roomManagementStatus = {};

        // --- HILFSFUNKTIONEN ---

        function showMessage(text, isError = false) {
            const messageBox = document.getElementById('message-box');
            messageBox.textContent = text;
            messageBox.className = `p-3 rounded-xl mb-4 text-center text-sm font-medium ${isError ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'}`;
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 5000);
        }

        // Hilfsfunktion, um alle Konflikte abzurufen (Fixed + Dynamic)
        function getAllConflictsWithReasons() {
            return CONFLICT_PAIRS_FIXED.concat(dynamicConflicts);
        }

        // Hilfsfunktion, um den Grund f√ºr ein spezifisches Paar zu finden
        function getConflictReason(personA, personB) {
            const allConflicts = getAllConflictsWithReasons();
            const foundConflict = allConflicts.find(pair => 
                (pair[0] === personA && pair[1] === personB) || 
                (pair[0] === personB && pair[1] === personA)
            );
            return foundConflict ? foundConflict[2] : null; // Gibt den Grund zur√ºck
        }

        function isConflict(personA, personB, allConflicts) {
            return allConflicts.some(pair => 
                (pair[0] === personA && pair[1] === personB) || 
                (pair[0] === personB && pair[1] === personA)
            );
        }

        function displayConflictStory(personA, personB, reason) {
            const displayBox = document.getElementById('conflict-story-display');
            const pairDisplay = document.getElementById('conflict-pair-display');
            const reasonText = document.getElementById('conflict-reason-text');
            
            if (reason) {
                pairDisplay.textContent = `${personA} ‚ÜîÔ∏è ${personB}`;
                reasonText.textContent = reason;
                displayBox.style.display = 'block';
            } else {
                displayBox.style.display = 'none';
            }
        }
        
        // ===================================
        // TAIS MATH CHALLENGE LOGIK (DYNAMISCH)
        // ===================================

        function generateTaisMathProblem() {
            // Generiert eine quadratische Gleichung x¬≤ + bx + c = 0 mit ganzzahligen Wurzeln.
            // Die Aufgabe ist, die gr√∂√üere Wurzel zu finden.
            
            let r1 = Math.floor(Math.random() * 5) + 3; // Positive Wurzel: 3 bis 7
            let r2;

            do {
                // Negative/Kleine Wurzel: -5 bis 2 (ohne 0 und ohne r1)
                let candidate = Math.floor(Math.random() * 8) - 5; 
                if (candidate !== 0 && candidate !== r1) {
                    r2 = candidate;
                }
            } while (r2 === undefined);

            // Gleichung: x^2 - (r1 + r2)x + (r1 * r2) = 0
            const b = -(r1 + r2);
            const c = r1 * r2;
            
            const roots = [r1, r2].sort((a, b) => a - b);
            const correctAnswer = roots[1]; // Immer die gr√∂√üere Wurzel

            // Formatierung f√ºr die Anzeige (Entfernt unn√∂tige 1er und +0)
            const b_term = (b === 0) ? '' : ((b > 0) ? `+ ${b}` : `- ${Math.abs(b)}`) + (Math.abs(b) === 1 ? 'x' : 'x');
            const c_term = (c === 0) ? '' : ((c > 0) ? `+ ${c}` : `- ${Math.abs(c)}`);

            let question = `x¬≤${b_term}${c_term}`;
            
            // Bereinigung des x-Terms
            question = question.replace('+ 1x', '+ x').replace('- 1x', '- x').trim();
            // Stellt sicher, dass das x¬≤ am Anfang nicht mit einem Pluszeichen beginnt (z.B. wenn b=0 und c<0)
            question = question.startsWith('+') ? question.substring(1).trim() : question;
            
            // Ersetze x¬≤ durch $x^2$ f√ºr die Darstellung (Markdown/HTML-Superscript)
            question = question.replace('x¬≤', '$x^2$');

            return {
                question: `L√∂se die quadratische Gleichung: ${question} = 0. W√§hle die *gr√∂√üere* L√∂sung.`,
                answer: correctAnswer,
                currentRoots: roots
            };
        }

        function showTaisMathChallenge(dropData) {
            const modal = document.getElementById('tais-math-modal');
            const submitBtn = document.getElementById('submit-tais-math');
            const cancelBtn = document.getElementById('cancel-tais-math');
            const answerInput = document.getElementById('tais-math-answer');
            const errorMsg = document.getElementById('tais-math-error');
            const questionEl = document.getElementById('math-question');
            
            // Das dynamisch generierte Problem anzeigen
            questionEl.innerHTML = taisMathProblem.question;
            
            // Store drop data temporarily (personName is 'Tais', targetRoomId)
            modal.dataset.personName = dropData.personName;
            modal.dataset.targetRoomId = dropData.targetRoomId;
            
            errorMsg.style.display = 'none';
            answerInput.value = '';
            modal.style.display = 'flex';

            // Event-Listener neu zuweisen, um Drop-Daten zu erfassen
            submitBtn.onclick = () => handleTaisMathSubmit();
            cancelBtn.onclick = () => handleTaisMathFailure();
        }

        function handleTaisMathSubmit() {
            const answerInput = document.getElementById('tais-math-answer');
            const errorMsg = document.getElementById('tais-math-error');
            const modal = document.getElementById('tais-math-modal');
            
            const answer = parseInt(answerInput.value);
            
            if (isNaN(answer)) {
                errorMsg.textContent = "Bitte gib eine g√ºltige Zahl ein.";
                errorMsg.style.display = 'block';
                return;
            }

            if (answer === taisMathProblem.answer) {
                isTaisMathSolved = true;
                modal.style.display = 'none';
                showMessage("Tais ist beeindruckt! Der Logik-Test wurde bestanden. Du kannst sie jetzt zuweisen.", false);
                
                // Manuelles Ausl√∂sen des Zuweisungs-Vorgangs (simuliert den erfolgreichen Drop)
                const personName = modal.dataset.personName;
                const targetRoomId = modal.dataset.targetRoomId;

                const targetRoom = rooms.find(r => r.id === targetRoomId);
                
                if (targetRoom) {
                    // 1. Aus altem Zimmer entfernen
                    rooms.forEach(room => {
                        const index = room.occupants.indexOf(personName);
                        if (index > -1) {
                            room.occupants.splice(index, 1);
                        }
                    });
                    // 2. Zu neuem Zimmer hinzuf√ºgen
                    targetRoom.occupants.push(personName);
                }
                
                renderRoomGame();
                
            } else {
                handleTaisMathFailure(true); // Falsche Antwort
            }
        }

        function handleTaisMathFailure(wasWrongAnswer = false) {
            const modal = document.getElementById('tais-math-modal');
            modal.style.display = 'none';
            
            const personName = modal.dataset.personName; // 'Tais'
            
            if (!sickPersons.includes(personName)) {
                sickPersons.push(personName);
                
                // Tais ist TOTKRANK und muss aus jedem Zimmer entfernt werden (falls sie drin war)
                rooms.forEach(room => {
                    const index = room.occupants.indexOf(personName);
                    if (index > -1) {
                        room.occupants.splice(index, 1);
                    }
                });
                const failMessage = wasWrongAnswer 
                    ? `‚ùå Falsche L√∂sung! Tais (${personName}) ist sofort TOTKRANK geworden und MUSS unzugewiesen bleiben (Isolierung!).`
                    : `‚ùå Abgebrochen! Tais (${personName}) ist sofort TOTKRANK geworden, da du ihre Forderung ignoriert hast!`;
                
                showMessage(failMessage, true);
            } else {
                showMessage(`Tais ist bereits TOTKRANK. Du hast sie nicht von ihrem Logik-Trip abbringen k√∂nnen.`, true);
            }
            renderRoomGame();
        }
        
        // ===================================
        // ZIMMERORDNUNGS MODUS LOGIK (ERWEITERT)
        // ===================================

        function generateRoomLayout() {
            // NEUE LOGIK: Garantiert genau 20 Betten mit einer zuf√§lligen Mischung aus 2, 3, 4, 5
            const guaranteedSizes = [5, 5, 4, 3, 3]; 
            
            // Mischen der Gr√∂ssen f√ºr Abwechslung
            const shuffledSizes = guaranteedSizes.sort(() => 0.5 - Math.random());
            
            const generatedRooms = [];
            let roomId = 1;
            
            shuffledSizes.forEach(selectedSize => {
                generatedRooms.push({
                    id: `room-${roomId}`,
                    size: selectedSize,
                    occupants: [],
                    hasHeating: Math.random() < 0.5 // Zuf√§llige Heizung
                });
                roomId++;
            });
            
            rooms = generatedRooms;
        }

        function generateSickPersons() {
            // ... (unver√§nderte Logik)
            const sickCount = Math.floor(Math.random() * 4) + 2; // 2 bis 5 Kranke
            const shuffledNames = [...PERSON_NAMES].sort(() => 0.5 - Math.random());
            sickPersons = shuffledNames.slice(0, sickCount);
        }
        
        function updateRoomState() {
            // ... (unver√§nderte Logik)
            const currentTime = Date.now();
            const elapsedTime = Math.floor((currentTime - roomStartTime) / 1000);
            
            // --- 1. Timer aktualisieren ---
            document.getElementById('room-timer').textContent = `${elapsedTime}s`;

            // --- 2. Konflikt-Eskalation (Alle 30s) ---
            const requiredConflicts = Math.floor(elapsedTime / 30);
            
            if (nextConflictIndex < requiredConflicts && nextConflictIndex < NEW_CONFLICT_POOL.length) {
                const newConflict = NEW_CONFLICT_POOL[nextConflictIndex];
                // Wichtig: Wir pushen das gesamte Array [A, B, Grund]
                dynamicConflicts.push(newConflict); 
                nextConflictIndex++;
                showMessage(`NEUER KONFLIKT AKTIVIERT: ${newConflict[0]} hasst ${newConflict[1]}!`, true);
            }
            
            // Countdown f√ºr den n√§chsten Konflikt
            const nextActivationTime = (nextConflictIndex + 1) * 30;
            const timeToNextConflict = Math.max(0, nextActivationTime - elapsedTime);
            document.getElementById('conflict-countdown').textContent = `${timeToNextConflict}s`;

            // --- 3. Konflikt-Vergebung (Alle 60s) ---
            if (currentTime - lastForgivenessTime >= CONFLICT_FORGIVENESS_INTERVAL) {
                lastForgivenessTime = currentTime;
                
                if (dynamicConflicts.length > 0) {
                    const randomIndex = Math.floor(Math.random() * dynamicConflicts.length);
                    const conflictPair = dynamicConflicts[randomIndex];
                    
                    if (Math.random() < 0.1) { // 10% Chance
                        dynamicConflicts.splice(randomIndex, 1);
                        showMessage(`FRIEDEN: ${conflictPair[0]} und ${conflictPair[1]} haben sich vers√∂hnt!`, false);
                    }
                }
            }
            
            // Countdown f√ºr die n√§chste Vergebungs-Check
            const timeToNextForgiveness = Math.ceil((lastForgivenessTime + CONFLICT_FORGIVENESS_INTERVAL - currentTime) / 1000);
            document.getElementById('forgiveness-countdown').textContent = `${Math.max(0, timeToNextForgiveness)}s`;
            
            // --- 4. Viren-Ausbreitung (Alle 60s) ---
            if (currentTime - lastInfectionCheckTime >= INFECTION_CHECK_INTERVAL) {
                lastInfectionCheckTime = currentTime;
                
                const healthyPersons = PERSON_NAMES.filter(name => !sickPersons.includes(name));
                const newlyInfected = [];
                
                // 4.1 Unzugewiesene Infektion (Logik wie zuvor)
                const unassignedPersons = getUnassignedPersons();
                const sickUnassigned = unassignedPersons.filter(name => sickPersons.includes(name));
                const healthyUnassigned = unassignedPersons.filter(name => healthyPersons.includes(name));
                
                if (sickUnassigned.length > 0) {
                    healthyUnassigned.forEach(name => {
                        if (Math.random() < 0.1) { 
                            newlyInfected.push(name);
                        }
                    });
                }
                
                // 4.2 Zimmer-Infektion (Logik wie zuvor)
                rooms.forEach(room => {
                    const roomStatus = roomManagementStatus[room.id];
                    const sickRoom = room.occupants.filter(name => sickPersons.includes(name));
                    const healthyRoom = room.occupants.filter(name => healthyPersons.includes(name));
                    
                    if (sickRoom.length > 0 && healthyRoom.length > 0) {
                        // Der Fehler wird bereits durch Regel A in evaluateRooms blockiert, hier nur Viren-Ausbreitung, wenn ZUSAMMEN
                        healthyRoom.forEach(name => {
                            if (Math.random() < 0.5) { // Hohe Ansteckung im selben Zimmer
                                newlyInfected.push(name); 
                            }
                        });
                    } else if (sickRoom.length > 0 && healthyRoom.length === 0) {
                        // Viren-Ausbreitung, wenn Management-Regeln nicht beachtet werden, selbst wenn alle krank sind (Verletzung des Protokolls)
                        const isVented = (currentTime - roomStatus.lastVentTime) < INFECTION_CHECK_INTERVAL;
                        const isSafe = roomStatus.isDoorClosed && roomStatus.areMasksWorn && isVented;
                        
                        if (!isSafe && Math.random() < 0.3) {
                             console.warn(`VIRUS-PROTOKOLL VERLETZT IN ZIMMER ${room.id}! Management-Regeln ignoriert.`);
                        }
                    }
                });
                
                newlyInfected.forEach(name => {
                    if (!sickPersons.includes(name)) {
                        sickPersons.push(name);
                        showMessage(`ü¶† VIRUS-ALARM! ${name} ist jetzt krank!`, true);
                    }
                });
                
                if (newlyInfected.length > 0) renderRoomGame(); 
            }
            
            // Aktualisiere Status-Anzeigen
            renderConflictList();
            document.getElementById('sick-count').textContent = sickPersons.length;
            document.getElementById('sick-list').textContent = sickPersons.join(', ');
        }
        
        function startRoomTimer() {
            // ... (unver√§nderte Logik)
            stopRoomTimer(); 
            roomStartTime = Date.now();
            lastForgivenessTime = Date.now();
            lastInfectionCheckTime = Date.now();
            roomTimerInterval = setInterval(updateRoomState, 1000);
            updateRoomState(); 
        }
        
        function stopRoomTimer() {
            // ... (unver√§nderte Logik)
            if (roomTimerInterval) {
                clearInterval(roomTimerInterval);
                roomTimerInterval = null;
            }
        }
        
        function getUnassignedPersons() {
            // ... (unver√§nderte Logik)
            const assignedPersons = rooms.flatMap(r => r.occupants);
            return PERSON_NAMES.filter(name => !assignedPersons.includes(name));
        }

        function setupRoomGame() {
            // ... (unver√§nderte Logik)
            stopRoomTimer();
            generateRoomLayout();
            generateSickPersons();
            taisMathProblem = generateTaisMathProblem(); // NEU: Generiere das neue Problem

            rooms.forEach(room => room.occupants = []);
            roomProblemIds = [];
            dynamicConflicts = [];
            nextConflictIndex = 0;
            roomManagementStatus = {};
            isTaisMathSolved = false; // Tais-Status zur√ºcksetzen
            
            rooms.forEach(room => {
                roomManagementStatus[room.id] = {
                    lastVentTime: 0,
                    isDoorClosed: false,
                    areMasksWorn: false
                };
            });
            
            // Konflikt-Story-Box ausblenden
            document.getElementById('conflict-story-display').style.display = 'none';

            renderRoomGame();
            startRoomTimer();
        }
        
        function renderConflictList() {
            const conflictListEl = document.getElementById('dynamic-conflicts-list');

            if (dynamicConflicts.length === 0) {
                 conflictListEl.innerHTML = '<p class="text-xs italic text-indigo-600">Noch keine neuen Konflikte.</p>';
            } else {
                conflictListEl.innerHTML = dynamicConflicts.map(([a, b, reason]) => 
                    `<span class="conflict-new" data-a="${a}" data-b="${b}" onclick="displayConflictStory('${a}', '${b}', '${reason.replace(/'/g, "\\'")}')">
                        ${a} &harr; ${b}
                    </span>`
                ).join('');
            }
        }

        function renderRoomGame() {
            // ... (Logik zur Anzeige der Personen und Zimmer - unver√§ndert, au√üer f√ºr Konflikt-Listener)
            const assignedPersons = rooms.flatMap(r => r.occupants);
            const unassignedNames = PERSON_NAMES.filter(name => !assignedPersons.includes(name));
            const totalCapacity = rooms.reduce((sum, room) => sum + room.size, 0);

            // Update Status Display
            document.getElementById('total-capacity').textContent = totalCapacity;
            document.getElementById('used-capacity').textContent = assignedPersons.length;
            document.getElementById('unassigned-count').textContent = unassignedNames.length;
            document.getElementById('total-rooms').textContent = rooms.length;
            document.getElementById('sick-count').textContent = sickPersons.length;
            document.getElementById('sick-list').textContent = sickPersons.join(', ');

            // Rendere Unzugewiesene Personen
            const unassignedContainer = document.getElementById('unassigned-persons');
            unassignedContainer.innerHTML = unassignedNames.map(name => {
                const isSick = sickPersons.includes(name);
                const requiresHeating = NO_HEATING_TOLERANCE_PEOPLE.includes(name);
                
                let colorClass = isSick ? 'sick-person' : 'bg-indigo-500';
                
                let extraTag = '';
                if (requiresHeating && !isSick) {
                    extraTag = 'üî•';
                }
                
                // NEU: Kennzeichnung f√ºr Tais, wenn der Test nicht bestanden ist
                if (name === 'Tais' && !isTaisMathSolved && !isSick) {
                    extraTag = (extraTag ? extraTag + ' ' : '') + 'üß†';
                }


                return `
                    <span id="person-${name}" 
                          draggable="true" 
                          data-name="${name}" 
                          class="draggable-person px-3 py-1 text-xs font-semibold rounded-full text-white ${colorClass} shadow-sm transition hover:shadow-lg">
                        ${name} ${isSick ? 'ü§í' : extraTag}
                    </span>
                `;
            }).join('');
            
            // Rendere Zimmer
            const roomLayoutContainer = document.getElementById('room-layout');
            roomLayoutContainer.innerHTML = '';
            
            rooms.forEach((room, index) => {
                const status = roomManagementStatus[room.id];
                const problemClass = roomProblemIds.includes(room.id) ? 'border-red-500 bg-red-50' : 'border-indigo-300 bg-white';
                
                const occupantsHTML = room.occupants.map(name => {
                    const isSick = sickPersons.includes(name);
                    const requiresHeating = NO_HEATING_TOLERANCE_PEOPLE.includes(name);
                    
                    let colorClass = isSick ? 'sick-person' : 'bg-indigo-500';
                    let extraTag = '';
                    if (requiresHeating && !isSick) {
                        extraTag = 'üî•';
                    }

                    return `
                        <span id="person-${name}" 
                              draggable="true" 
                              data-name="${name}" 
                              class="draggable-person px-3 py-1 text-xs font-semibold rounded-full text-white ${colorClass} shadow-sm transition hover:shadow-lg">
                            ${name} ${isSick ? 'ü§í' : extraTag}
                        </span>
                    `;
                }).join('');

                const timeSinceVent = Math.floor((Date.now() - status.lastVentTime) / 1000);
                const ventStatus = timeSinceVent <= 60 ? 'bg-green-100 text-green-700' : 'bg-yellow-100 text-yellow-700';

                const heatingStatusIcon = room.hasHeating ? 'üî• Heizung: Ja' : 'üßä Heizung: Nein';
                const heatingStatusClass = room.hasHeating ? 'bg-green-100 text-green-700' : 'bg-orange-100 text-orange-700 font-bold'; 

                const roomHTML = `
                    <div id="${room.id}" 
                         data-room-id="${room.id}"
                         data-size="${room.size}"
                         class="drop-zone room-card p-4 rounded-xl border-2 ${problemClass} space-y-3">
                        
                        <h4 class="w-full text-sm font-bold text-gray-700">Zimmer ${index + 1} (${room.size}er) - Belegt: ${room.occupants.length} / ${room.size}</h4>
                        
                        <div class="p-2 rounded-lg text-xs font-semibold text-center ${heatingStatusClass}">
                            ${heatingStatusIcon}
                        </div>


                        <!-- Management Controls -->
                        <div class="flex flex-wrap gap-2 justify-between border-t pt-2 border-gray-200">
                            <button onclick="toggleRoomManagement('${room.id}', 'vent', true)" 
                                    class="management-btn ${ventStatus}">
                                üå¨Ô∏è L√ºften (Vent: ${Math.min(timeSinceVent, 60)}s)
                            </button>

                            <button onclick="toggleRoomManagement('${room.id}', 'door', ${!status.isDoorClosed})" 
                                    class="management-btn ${status.isDoorClosed ? 'bg-green-500 text-white' : 'bg-red-500 text-white'}">
                                ${status.isDoorClosed ? 'üö™ Zu' : 'üö™ Offen'}
                            </button>

                            <button onclick="toggleRoomManagement('${room.id}', 'mask', ${!status.areMasksWorn})" 
                                    class="management-btn ${status.areMasksWorn ? 'bg-green-500 text-white' : 'bg-red-500 text-white'}">
                                ${status.areMasksWorn ? 'üò∑ Maske' : 'üôÅ Keine Maske'}
                            </button>
                        </div>

                        <!-- Occupants -->
                        <div class="flex flex-wrap gap-2 pt-2 min-h-[2rem]">
                            ${room.occupants.length === 0 ? '<p class="text-gray-400 text-sm italic">Personen hierher ziehen...</p>' : occupantsHTML}
                        </div>
                    </div>
                `;
                roomLayoutContainer.innerHTML += roomHTML;
            });
            
            if (roomProblemIds.length === 0) {
                 document.getElementById('room-results').style.display = 'none';
            }
            
            initDragAndDrop();
        }

        function initDragAndDrop() {
            const draggables = document.querySelectorAll('.draggable-person');
            const dropZones = document.querySelectorAll('.drop-zone');

            draggables.forEach(person => {
                person.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', e.target.dataset.name);
                    setTimeout(() => person.classList.add('opacity-50'), 0);
                });

                person.addEventListener('dragend', (e) => {
                    e.target.classList.remove('opacity-50');
                });
            });

            dropZones.forEach(zone => {
                zone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    zone.classList.add('drag-over');
                });

                zone.addEventListener('dragleave', (e) => {
                    zone.classList.remove('drag-over');
                });

                zone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    zone.classList.remove('drag-over');
                    
                    const personName = e.dataTransfer.getData('text/plain');
                    const droppedOnRoomId = zone.id.startsWith('room-') ? zone.id : 'unassigned-persons';
                    
                    // Allgemeine Kranke-Person-Regel: Kranke d√ºrfen nicht in Zimmer
                    const isPersonSick = sickPersons.includes(personName);
                    
                    if (isPersonSick && droppedOnRoomId !== 'unassigned-persons') {
                        showMessage(`${personName} ist krank (ü§í) und muss isoliert bleiben. Zimmerzuweisung verboten.`, true);
                        renderRoomGame(); 
                        return;
                    }
                    
                    // --- TAIS-LOGIK-PR√úFUNG ---
                    if (personName === 'Tais' && droppedOnRoomId !== 'unassigned-persons' && !isTaisMathSolved && !isPersonSick) {
                        showTaisMathChallenge({ personName: personName, targetRoomId: droppedOnRoomId });
                        return; 
                    }

                    // --- Normale Drop-Logik ---

                    rooms.forEach(room => {
                        const index = room.occupants.indexOf(personName);
                        if (index > -1) {
                            room.occupants.splice(index, 1);
                        }
                    });

                    if (droppedOnRoomId !== 'unassigned-persons') {
                        const targetRoom = rooms.find(r => r.id === droppedOnRoomId);
                        if (targetRoom && targetRoom.occupants.length < targetRoom.size) {
                            targetRoom.occupants.push(personName);
                        } else if (targetRoom) {
                             showMessage(`Zimmer ${targetRoom.id.replace('room-', '')} ist bereits voll (${targetRoom.size}er).`, true);
                        }
                    }

                    renderRoomGame();
                });
            });
        }

        function evaluateRooms() {
            // Timer stoppen, da die Bewertung beginnt
            stopRoomTimer();
            updateRoomState(); // Finales Update vor der Bewertung
            
            roomProblemIds = [];
            const results = [];
            let allAssigned = true;
            let success = true;
            
            const allConflicts = getAllConflictsWithReasons();
            const currentTime = Date.now();
            let firstConflictReason = null; 

            // 1. NEUE REGEL: Check, ob alle zugewiesen sind
            const unassignedCount = getUnassignedPersons().length;
            
            if (unassignedCount > 0) {
                results.push(`‚ùå ZUWEISUNGSFEHLER! ${unassignedCount} Person(en) sind unzugewiesen (${getUnassignedPersons().join(', ')}). ALLE m√ºssen in einem Zimmer sein.`);
                allAssigned = false;
                success = false;
            }
            
            // 2. Allgemeine Zimmer-Regeln und Konflikte
            rooms.forEach(room => {
                let roomProblem = false;
                let conflictPairsFound = [];
                const occupants = room.occupants;
                const status = roomManagementStatus[room.id];
                
                if (occupants.length === 0) return;
                
                // Regel D: Heizungsbedarf
                if (!room.hasHeating) {
                    occupants.forEach(name => {
                        if (NO_HEATING_TOLERANCE_PEOPLE.includes(name)) {
                            roomProblem = true;
                            results.push(`‚ùå Zimmer ${room.id.replace('room-', '')}: ${name} MUSS in einem Zimmer mit Heizung (üî•) untergebracht werden.`);
                            success = false;
                        }
                    });
                }
                
                // Regel A: Krankheits-Isolation
                const sickInRoom = occupants.filter(name => sickPersons.includes(name));
                const healthyInRoom = occupants.length - sickInRoom.length;
                
                if (sickInRoom.length > 0 && healthyInRoom > 0) {
                    roomProblem = true;
                    results.push(`‚ùå Zimmer ${room.id.replace('room-', '')}: Kranke (${sickInRoom.join(', ')}) d√ºrfen NICHT mit Gesunden (${occupants.filter(n => !sickPersons.includes(n)).join(', ')}) zusammen sein.`);
                    success = false;
                }
                
                // Regel B: Soziale Konflikte (Fixed UND Dynamic)
                for (let i = 0; i < occupants.length; i++) {
                    for (let j = i + 1; j < occupants.length; j++) {
                        const personA = occupants[i];
                        const personB = occupants[j];
                        
                        // Wenn einer der beiden krank ist, wird der Konflikt ignoriert
                        const isA_Sick = sickPersons.includes(personA);
                        const isB_Sick = sickPersons.includes(personB);

                        if (isA_Sick || isB_Sick) {
                            continue; 
                        }

                        if (isConflict(personA, personB, allConflicts)) {
                            if (!roomProblem) roomProblem = true;
                            conflictPairsFound.push(`${personA} & ${personB}`);
                            success = false;
                            
                            // Speichere den Grund des ERSTEN Konflikts f√ºr die Anzeige
                            if (!firstConflictReason) {
                                firstConflictReason = {
                                    pair: `${personA} ‚ÜîÔ∏è ${personB}`,
                                    reason: getConflictReason(personA, personB)
                                };
                            }
                        }
                    }
                }
                
                if (conflictPairsFound.length > 0) {
                    results.push(`‚ùå Zimmer ${room.id.replace('room-', '')}: Soziale Konflikte gefunden (${conflictPairsFound.join(', ')}).`);
                }
                
                // Regel C: Zimmer-Management Check
                const isVented = (currentTime - status.lastVentTime) < INFECTION_CHECK_INTERVAL;
                
                if (sickInRoom.length > 0) {
                    if (!status.isDoorClosed || !status.areMasksWorn || !isVented) {
                        results.push(`‚ö†Ô∏è Zimmer ${room.id.replace('room-', '')}: Management MANGELHAFT (T√ºr: ${status.isDoorClosed ? '‚úÖ' : '‚ùå'}, Maske: ${status.areMasksWorn ? '‚úÖ' : '‚ùå'}, L√ºftung: ${isVented ? '‚úÖ' : '‚ùå'}).`);
                        success = false; 
                    }
                }

                if (roomProblem || (sickInRoom.length > 0 && (!status.isDoorClosed || !status.areMasksWorn || !isVented))) {
                    if (!roomProblemIds.includes(room.id)) roomProblemIds.push(room.id);
                }
            });
            
            // 3. Ausgabe des Ergebnisses
            const resultContainer = document.getElementById('room-results');
            const resultText = document.getElementById('room-result-text');
            const finalTime = document.getElementById('room-timer').textContent;

            // Konflikt-Story-Anzeige aktualisieren
            if (firstConflictReason) {
                displayConflictStory(firstConflictReason.pair.split(' ‚ÜîÔ∏è ')[0], firstConflictReason.pair.split(' ‚ÜîÔ∏è ')[1], firstConflictReason.reason);
            } else {
                document.getElementById('conflict-story-display').style.display = 'none';
            }

            if (success && allAssigned && roomProblemIds.length === 0 && sickPersons.length <= 5) { // Max 5 Kranke am Start
                resultContainer.className = 'mt-6 p-4 border border-green-500 bg-green-100 rounded-xl';
                resultText.innerHTML = `<span class="font-semibold text-lg">GROSSARTIG!</span> Die Zimmerordnung ist perfekt. Alle sind gl√ºcklich und gesund! Die Logistik dauerte nur: <span class="font-bold text-xl">${finalTime}</span>.`;
            } else if (sickPersons.length > 10) {
                resultContainer.className = 'mt-6 p-4 border border-red-500 bg-red-100 rounded-xl';
                 resultText.innerHTML = `<span class="font-semibold text-lg">KATASROPHE!</span> Die H√§lfte der Klasse ist krank geworden (${sickPersons.length} Personen). Die Logistik ist gescheitert.`;
                 stopRoomTimer();
            } else {
                resultContainer.className = 'mt-6 p-4 border border-red-500 bg-red-100 rounded-xl';
                let output = `Es gibt Probleme in deiner Zimmerordnung: <span class="font-bold">(${sickPersons.length} Personen sind am Ende krank)</span>`;
                output += '<ul class="list-disc ml-5 mt-2 space-y-1">';
                
                results.forEach(msg => {
                    output += `<li>${msg}</li>`;
                });
                
                if (roomProblemIds.length > 0 && !results.some(msg => msg.includes('Probleme gefunden in den Zimmern'))) {
                    output += `<li class="font-semibold">Problematische Zimmer: ${roomProblemIds.map(id => id.replace('room-', '')).join(', ')}</li>`;
                }

                output += '</ul>';
                resultText.innerHTML = output;
            }
            
            resultContainer.style.display = 'block';
            renderRoomGame(); 
            startRoomTimer(); // Timer l√§uft f√ºr weitere Versuche weiter, bis gestoppt wird
        }


        // ===================================
        // ALLGEMEINE INITIALISIERUNG
        // ===================================

        function toggleRoomManagement(roomId, controlType, value) {
            if (!roomManagementStatus[roomId]) return;
            
            if (controlType === 'vent') {
                roomManagementStatus[roomId].lastVentTime = Date.now();
                showMessage(`Zimmer ${roomId.replace('room-', '')} gel√ºftet! N√§chste L√ºftung in 60s.`);
            } else if (controlType === 'door') {
                roomManagementStatus[roomId].isDoorClosed = value;
                showMessage(`Zimmer ${roomId.replace('room-', '')}: T√ºr ist jetzt ${value ? 'geschlossen' : 'offen'}.`);
            } else if (controlType === 'mask') {
                roomManagementStatus[roomId].areMasksWorn = value;
                showMessage(`Zimmer ${roomId.replace('room-', '')}: Masken sind jetzt ${value ? 'aufgesetzt' : 'abgesetzt'}.`);
            }
            renderRoomGame(); 
        }

        function switchMode(mode) {
            gameState = mode;
            const guessDiv = document.getElementById('guess-game');
            const roomDiv = document.getElementById('room-game');
            const guessBtn = document.getElementById('switch-guess');
            const roomBtn = document.getElementById('switch-room');
            
            if (mode === 'guess') {
                guessDiv.style.display = 'block';
                roomDiv.style.display = 'none';
                guessBtn.classList.add('bg-indigo-500', 'text-white', 'shadow-md');
                guessBtn.classList.remove('border', 'border-indigo-500', 'text-indigo-700', 'hover:bg-indigo-50');
                roomBtn.classList.remove('bg-indigo-500', 'text-white', 'shadow-md');
                roomBtn.classList.add('border', 'border-indigo-500', 'text-indigo-700', 'hover:bg-indigo-50');
                stopRoomTimer();
            } else {
                guessDiv.style.display = 'none';
                roomDiv.style.display = 'block';
                roomBtn.classList.add('bg-indigo-500', 'text-white', 'shadow-md');
                roomBtn.classList.remove('border', 'border-indigo-500', 'text-indigo-700', 'hover:bg-indigo-50');
                guessBtn.classList.remove('bg-indigo-500', 'text-white', 'shadow-md');
                guessBtn.classList.add('border', 'border-indigo-500', 'text-indigo-700', 'hover:bg-indigo-50');
                setupRoomGame();
            }
        }
        
        function initializeApp() {
            // Initialisiere Room Game Listeners
            document.getElementById('submit-rooms-btn').onclick = evaluateRooms;
            document.getElementById('new-room-game-btn').onclick = setupRoomGame;

            // Initialisiere Mode Switcher
            document.getElementById('switch-guess').onclick = () => switchMode('guess');
            document.getElementById('switch-room').onclick = () => switchMode('room');
            
            // Starte standardm√§ssig mit dem Zimmer-Modus
            switchMode('room');
        }

        window.onload = initializeApp;
    </script>
</body>
</html>
